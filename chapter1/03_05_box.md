# 盒模型

在讲解 CSS 布局之前，我们回顾一些知识，在前面 HTML 章节中，我们有根据元素的显示效果进行分类，分为：块状元素、内联元素（ 又叫行内元素 ）和内联块状元素。

* 常见的块状元素有：`div`，`h1`~`h6`，`ol`，`ul`，`li`，`dl`，`dt`，`dd`，`p`，`form`

* 常见的内联元素有：`span`，`label`，`strong`，`em`，`b`

* 常见的内联块状元素有：`img`，`input`


如果对这三种类别元素的显示效果还比较默认的同学，可以查看 [《HTML基础 - 标签分类》](/chapter1/02_03_type.md) 章节。

回顾了必要的知识，那接下来就正式开始这一小节的学习了。

## 什么是盒模型？

所有 HTML 元素在页面中都会形成一个矩形盒子，渲染引擎根据给定的样式确定这个盒子的呈现。在 CSS 中，"box model" 这一术语是用来设计和布局时使用，那换句话说页面的布局就是一个个盒子的排列和摆放。

CSS 盒模型用于封装周围的 HTML 元素，它包括：边距，边框，填充和实际内容。

盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。

下面的图片说明了盒子模型\(Box Model\)：

![](/assets/css-box.png)

不同部分的说明：

* Margin\(外边距\) - 清除边框外的区域，外边距是透明的。
* Border\(边框\) - 围绕在内边距和内容外的边框。
* Padding\(内边距\) - 清除内容周围的区域，内边距是透明的。
* Content\(内容\) - 盒子的内容，显示文本和图像。

当我们指定一个CSS元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完全大小的元素，你还必须添加填充，边框和边距。

例如下面的例子：

```
width:250px;
padding:10px;
border:5px solid gray;
margin:10px; 
```

250px \(宽\)+ 20px \(left + 右填充\)+ 10px \(left + 右边框\)+ 20px \(left + 右边距\)= 300px

最终元素的总宽度计算公式是这样的：

总元素的宽度 = 宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距

元素的总高度最终计算公式是这样的：

总元素的高度 = 高度 + 顶部填充 + 底部填充 + 上边框 + 下边框 + 上边距 + 下边距

## CSS 边框

元素的边框 \(border\) 是围绕元素内容和内边距的一条或多条线。CSS border 属性允许你规定元素边框的样式、宽度和颜色。

### 边框与背景

CSS 规范指出，边框绘制在“元素的背景之上”。这很重要，因为有些边框是“间断的”（例如，点线边框或虚线框），元素的背景应当出现在边框的可见部分之间。

CSS2 指出背景只延伸到内边距，而不是边框。后来 CSS2.1 进行了更正：元素的背景是内容、内边距和边框区的背景。大多数浏览器都遵循 CSS2.1 定义，不过一些较老的浏览器可能会有不同的表现。

### 边框简写属性

```
border:border-width  border-style (required)  border-color;
```

###### 边框-单独设置各边

在CSS中，可以指定不同的侧面不同的边框：

```
p
{
border-top-style:dotted;
border-right-style:solid;
border-bottom-style:dotted;
border-left-style:solid;
}
```

上面的也可以设置一个单一属性：

```
border-style:dotted solid;
```

border-style属性可以有1-4个值：

```
border-style:dotted solid double dashed;
```

* 上边框是 dotted
* 右边框是 solid
* 底边框是 double
* 左边框是 dashed

```
border-style:dotted solid double;
```

* 上边框是 dotted
* 左、右边框是 solid
* 底边框是 double

```
border-style:dotted solid;
```

* 上、底边框是 dotted
* 右、左边框是 solid

```
border-style:dotted;
```

* 四面边框是 dotted

上面的例子只是以为例border-style。然而，它也可以和border-width 、 border-color一起使用。

###### 边框的样式

边框样式属性指定要显示什么样的边界。`border-style` 属性用来定义边框的样式

| 属性值 | 说明 |
| --- | --- |
| none: | 默认无边框 |
| dotted: | 定义一个点线框 |
| dashed: | 定义一个虚线框 |
| solid: | 定义实线边界 |
| double: | 定义两个边界。 两个边界的宽度和border-width的值相同 |
| groove: | 定义3D沟槽边界。效果取决于边界的颜色值 |
| ridge: | 定义3D脊边界。效果取决于边界的颜色值 |
| inset: | 定义一个3D的嵌入边框。效果取决于边界的颜色值 |
| outset: | 定义一个3D突出边框。 效果取决于边界的颜色值 |

###### 边框宽度

通过  `border-width` 属性为边框指定宽度。

为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em；或者使用 3 个关键字之一，它们分别是 thin 、medium（默认值） 和 thick。

注意：CSS 没有定义 3 个关键字的具体宽度，所以一个用户代理可能把 thin 、medium 和 thick 分别设置为等于 5px、3px 和 2px，而另一个用户代理则分别设置为 3px、2px 和 1px。

### 边框颜色

`border-color`属性用于设置边框的颜色。可以设置的颜色：

* name - 指定颜色的名称，如 "red"
* RGB - 指定 RGB 值, 如 "rgb\(255,0,0\)"
* Hex - 指定16进制值, 如 "\#ff0000"

您还可以设置边框的颜色为"transparent"。

注意： border-color单独使用是不起作用的，必须得先使用border-style来设置边框样式。

### 没有边框

如果希望显示某种边框，就必须设置边框样式，比如 solid 或 outset。

那么如果把 border-style 设置为 none 会出现什么情况

```
p {border-style: none; border-width: 50px;}
```

尽管边框的宽度是 50px，但是边框样式设置为 none。在这种情况下，不仅边框的样式没有了，其宽度也会变成 0。边框消失了，为什么呢？
这是因为如果边框样式为none，即边框根本不存在，那么边框就不可能有宽度，因此边框宽度自动设置为 0，而不论您原先定义的是什么。记住这一点非常重要。

根据以下规则，所有 h1 元素都不会有任何边框，更不用说 20 像素宽了：

```
h1 {border-width: 20px;}
```

由于 border-style 的默认值是 none，如果没有声明样式，就相当于 border-style: none。因此，如果您希望边框出现，就必须声明一个边框样式。

## 高度\/宽度

在 CSS 中，`width 和 height` 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。

### 宽度

使用 `width`属性 定义元素内容区的宽度，但是行内非替换元素会忽略这个属性。

注意（height属性不包括填充，边框，或页边距！）

### 高度

使用`height`属性设置元素的高度，但是行内非替换元素会忽略这个属性。

注意（height属性不包括填充，边框，或页边距！）

### 高度宽度可能的值

| 值 | 描述 |
| --- | --- |
| auto | 默认值。浏览器可计算出实际的宽度。 |
| length | 使用 px、cm 等单位定义宽度。 |
| % | 定义基于包含块（父元素）宽度的百分比宽度。 |
| inherit | 规定应该从父元素继承 width 属性的值。 |

## 内边距

元素的内边距在边框和内容区之间。控制该区域最简单的属性是 padding 属性。CSS padding 属性定义元素边框与元素内容之间的空白区域。

padding 属性接受长度值或百分比值，但不允许使用负值。

例如，如果希望所有 h1 元素的各边都有 10 像素的内边距，只需要这样：

```
h1 {padding: 10px;}
```

还可以按照上、右、下、左的顺序分别设置各边的内边距，各边均可以使用不同的单位或百分比值：

```
h1 {padding: 10px 0.25em 2ex 20%;}
```

### 单边内边距属性

通过使用下面四个单独的属性，分别设置上、右、下、左内边距：

* padding-top
* padding-right
* padding-bottom
* padding-left

你也许已经想到了，下面的规则实现的效果与上面的简写规则是完全相同的：

```
h1 {
  padding-top: 10px;
  padding-right: 0.25em;
  padding-bottom: 2ex;
  padding-left: 20%;
  }
```

### 内边距的百分比数值

前面提到过，可以为元素的内边距设置百分数值。百分数值是相对于其父元素的 width 计算的，这一点与外边距一样。所以，如果父元素的 width 改变，它们也会改变。

下面这条规则把段落的内边距设置为父元素 width 的 10%：

```
p {padding: 10%;} 
```

例如：如果一个段落的父元素是 div 元素，那么它的内边距要根据 div 的 width 计算。

```
<div style="width: 200px;">
<p>This paragragh is contained within a DIV that has a width of 200 pixels.</p>
</div> 
```

==注意==：上下内边距与左右内边距一致；即上下内边距的百分数会相对于父元素宽度设置，而不是相对于高度。

### 所有的CSS填充属性

| 属性 | 说明 |
| --- | --- |
| padding | 使用缩写属性设置在一个声明中的所有填充属性 |
| padding-bottom | 设置元素的底部填充 |
| padding-left | 设置元素的左部填充 |
| padding-right | 设置元素的右部填充 |
| padding-top | 设置元素的顶部填充 |

## 外边距

围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。

设置外边距的最简单的方法就是使用 margin 属性，这个属性接受任何长度单位、百分数值甚至负值。

### margin 属性

设置外边距的最简单的方法就是使用 `margin`属性。

margin 属性接受任何长度单位，可以是像素、英寸、毫米或 em。

margin 可以设置为 auto。更常见的做法是为外边距设置长度值。下面的声明在 h1 元素的各个边上设置了 1\/4 英寸宽的空白：

```
h1 {margin : 0.25in;}
```

下面的例子为 h1 元素的四个边分别定义了不同的外边距，所使用的长度单位是像素 \(px\)：

```
h1 {margin : 10px 0px 15px 5px;}
```

与内边距的设置相同，这些值的顺序是从上外边距 \(top\) 开始围着元素顺时针旋转的：

```
margin: top right bottom left
```

另外，还可以为 margin 设置一个百分比数值：

```
p {margin : 5%;}
```

百分数是相对于父元素的 width 计算的。上面这个例子为 p 元素设置的外边距是其==父元素==的 ==width== 的 10%。

==margin 的默认值是 0==，所以如果没有为 margin 声明一个值，就不会出现外边距。但是，在实际中，浏览器对许多元素已经提供了预定的样式，外边距也不例外。例如，在支持 CSS 的浏览器中，外边距会在每个段落元素的上面和下面生成“空行”。因此，如果没有为 p 元素声明外边距，浏览器可能会自己应用一个外边距。当然，只要你特别作了声明，就会覆盖默认样式。

### 值复制

有时，我们会输入一些重复的值：

```
p {margin: 0.5em 1em 0.5em 1em;}
```

通过值复制，您可以不必重复地键入这对数字。上面的规则与下面的规则是等价的：

```
p {margin: 0.5em 1em;}
```

这两个值可以取代前面 4 个值。这是如何做到的呢？CSS定义了一些规则，允许为外边距指定少于 4 个值。规则如下：

* 如果缺少左外边距的值，则使用右外边距的值。
* 如果缺少下外边距的值，则使用上外边距的值。
* 如果缺少右外边距的值，则使用上外边距的值。

下图提供了更直观的方法来了解这一点：

![](http://www.w3school.com.cn/i/ct_css_margin_value.gif)

换句话说，如果为外边距指定了 3 个值，则第 4 个值（即左外边距）会从第 2 个值（右外边距）复制得到。如果给定了两个值，第 4 个值会从第 2 个值复制得到，第 3 个值（下外边距）会从第 1 个值（上外边距）复制得到。最后一个情况，如果只给定一个值，那么其他 3 个外边距都由这个值（上外边距）复制得到。

利用这个简单的机制，您只需指定必要的值，而不必全部都应用 4 个值，例如：

```
h1 {margin: 0.25em 1em 0.5em;}    /* 等价于 0.25em 1em 0.5em 1em */
h2 {margin: 0.5em 1em;}        /* 等价于 0.5em 1em 0.5em 1em */
p {margin: 1px;}            /* 等价于 1px 1px 1px 1px */
```

这种办法有一个小缺点，您最后肯定会遇到这个问题。假设希望把 p 元素的上外边距和左外边距设置为 20 像素，下外边距和右外边距设置为 30 像素。在这种情况下，必须写作：

```
p {margin: 20px 30px 30px 20px;}
```

这样才能得到您想要的结果。遗憾的是，在这种情况下，所需值的个数没有办法更少了。

再来看另外一个例子。如果希望除了左外边距以外所有其他外边距都是 auto（左外边距是 20px）：

```
p {margin: auto auto auto 20px;}
```

同样的，这样才能得到你想要的效果。问题在于，键入这些 auto 有些麻烦。如果您只是希望控制元素单边上的外边距，请使用单边外边距属性。

### 单边外边距属性

可以使用单边外边距属性为元素单边上的外边距设置值。假设您希望把 p 元素的左外边距设置为 20px。不必使用 margin（需要键入很多 auto），而是可以采用以下方法：

```
p {margin-left: 20px;}
```

可以使用下列任何一个属性来只设置相应上的外边距，而不会直接影响所有其他外边距：

* margin-top
* margin-right
* margin-bottom
* margin-left

一个规则中可以使用多个这种单边属性，例如：

```
h2 {
  margin-top: 20px;
  margin-right: 30px;
  margin-bottom: 30px;
  margin-left: 20px;
  }
```

当然，对于这种情况，使用 margin 可能更容易一些：

```
p {margin: 20px 30px 30px 20px;} 
```

不论使用单边属性还是使用 margin，得到的结果都一样。一般来说，如果希望为多个边设置外边距，使用 margin 会更容易一些。不过，从文档显示的角度看，实际上使用哪种方法都不重要，所以应该选择对自己来说更容易的一种方法。

### 外边距属性

| 属性 | 描述 |
| --- | --- |
| margin | 简写属性。在一个声明中设置所有外边距属性。 |
| margin-bottom | 设置元素的下外边距。 |
| margin-left | 设置元素的左外边距。 |
| margin-right | 设置元素的右外边距。 |
| margin-top | 设置元素的上外边距。 |

## 外边距合并

外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。

合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。

### 合并

外边距合并（叠加）是一个相当简单的概念。但是，在实践中对网页进行布局时，它会造成许多混淆。

简单地说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。

当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。请看下图：

![](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_1.gif)

如下demo

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>盒子模型-外边距合并</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        #d1 {
            width:100px;
            height:100px;
            margin-top:20px;
            margin-bottom:20px;
            background-color:red;
            }

        #d2 {
            width:100px;
            height:100px;
            margin-top:10px;
            background-color:blue;
            }

    </style>
</head>
<body>
    <div id="d1"></div>
    <div id="d2"></div>
    <p>请注意，两个 div 之间的外边距是 20px，而不是 30px（20px + 10px）。</p>

</body>
</html>
```

当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和\/或下外边距也会发生合并。请看下图：

![](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_2.gif)

如下demo

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>盒子模型-外边距合并</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        #outer {
            width:300px;
            height:300px;
            background-color:red;
            margin-top:20px;
            }

        #inner {
            width:50px;
            height:50px;
            background-color:blue;
            margin-top:10px;
            }
    </style>
</head>
<body>
    <div id="outer">
        <div id="inner">
        </div>
    </div>
    <p>注释：请注意，如果不设置 div 的内边距和边框，那么内部 div 的上外边距将与外部 div 的上外边距合并（叠加）。</p>
</body>
</html>
```

尽管看上去有些奇怪，但是外边距甚至可以与自身发生合并。

假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并：

![](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_3.gif)

如果这个外边距遇到另一个元素的外边距，它还会发生合并：

![](http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_4.gif)

这就是一系列的段落元素占用空间非常小的原因，因为它们的所有外边距都合并到一起，形成了一个小的外边距。

外边距合并初看上去可能有点奇怪，但是实际上，它是有意义的。以由几个段落组成的典型文本页面为例。第一个段落上面的空间等于段落的上外边距。如果没有外边距合并，后续所有段落之间的外边距都将是相邻上外边距和下外边距的和。这意味着段落之间的空间是页面顶部的两倍。如果发生外边距合并，段落之间的上外边距和下外边距就合并在一起，这样各处的距离就一致了。

![](http://www.w3school.com.cn/i/ct_css_margin_collapsing.gif)

==注释==：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。

### 垂直margin可能在一些盒模型中被折叠

1. 在常规文档流中，2个或以上的块级盒模型相邻的垂直margin会被折叠。 

最终的margin值计算方法如下：

* a、全部都为正值，取最大者；

* b、不全是正值，则都取绝对值，然后用正值减去最大值；

* c、没有正值，则都取绝对值，然后用0减去最大值。


注意：相邻的盒模型可能由DOM元素动态产生并没有相邻或继承关系。

1. 相邻的盒模型中，如果其中的一个是浮动的（floated），垂直margin不会被折叠，甚至一个浮动的盒模型和它的子元素之间也是这样。
2. 设置了overflow属性的元素和它的子元素之间的margin不会被折叠（overflow取值为visible除外）
3. 设置了绝对定位（position:absolute）的盒模型，垂直margin不会被折叠，甚至和他们的子元素之间也是一样。 
4. 设置了display:inline-block的元素，垂直margin不会被折叠，甚至和他们的子元素之间也是一样。
5. 如果一个盒模型的上下margin相邻，这时它的margin可能折叠覆盖（collapse through）它。在这种情况下，元素的位置（position）取决于它的相邻元素的margin是否被折叠。 
6. 如果元素的margin和它的父元素的margin-top折叠在一起，盒模型border-top的边界定义和它的父元素相同。
7. 另外，任意元素的父元素不参与margin的折叠，或者说只有父元素的margin-bottom是参与计算的。如果元素的border-top非零，那么元素的border-top边界位置和原来一样。

  一个应用了清除操作的元素的margin-top绝不会和它的块级父元素的margin-bottom折叠。


注意，那些已经被折叠覆盖的元素的位置对其他已经被折叠的元素的位置没有任何影响；只有在对这些元素的子元素定位时，border-top边界位置才是必需的。

1. 根元素的垂直margin不会被折叠。

